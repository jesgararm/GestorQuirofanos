\capitulo{4}{Técnicas y herramientas}

\section{Metodología de Desarrollo}

Como metodología de desarrollo de nuestro proyecto, hemos tomado un enfoque \textbf{ágil}, inspirado en Scrum \cite{Palacio2022ScrumMaster}.

Para ello, se han dividido las diferentes tareas en Sprints, coincidiendo la finalización de cada Sprint con una \textbf{reunión} de los tutores y el desarrollador, finalizando en la confección de un \textbf{entregable} (\textit{release}).

\imagen{como-funciona-scrum}{Funcionamiento de Scrum. Fuente:\cite{SaezHurtado2021ComoUtilizarla}}{.8}

\subsection{Plataformas de Apoyo al Desarrollo}

\subsubsection{Repositorio y Git}

El código fuente, así como la \textbf{documentación} (incluyendo la Memoria y los Anexos) se encuentran en un \textit{repositorio Github} público, accesible desde: \href{https://github.com/jesgararm/GestorQuirofanos}{Repositorio: GestorQuirófanos}

Los \textbf{repositorios} constituyen el núcleo del trabajo en GitHub. A menudo, pueden ser representados como un microservicio, documentación, aplicación.. o todo en uno. 

La \textit{visibilidad} del mismo puede ser especificada, pudiéndose añadir \textit{colaboradores} con la posibilidad de editar la información contenida en él.

El \textbf{propietario} del repositorio es el alumno autor del proyecto, nombrándose como colaboradores los tutores del mismo.


\imagen{github}{Características y Posibilidades de GitHub. Fuente: \cite{Jones2018GettingGuide} }{.9}

\subsubsection{Calidad del Código}

Si bien es cierto que el objetivo principal de nuestro proyecto se centra en el diseño y explotación de algoritmos de \textit{inteligencia computacional}, hemos tratado de aplicar \textbf{buenas prácticas} de codificación y mantenimiento del código fuente, apoyándonos en la herramienta \href{https://codeclimate.com/github/jesgararm/GestorQuirofanos}{Code Climate}, debido a la \textit{sencillez} de su interfaz y la \textit{gratuidad} de sus servicios para proyectos \textit{Open-Source} como el nuestro.

Por otra parte, siguiendo el catálogo de Fowler\cite{Fowler1999Refactoring:Code}, se fueron aplicando diferentes \textbf{refactorizaciones} con el objetivo de mejorar las métricas de calidad del código fuente de cara a su integración final como API.


\section{Elementos de Programación}

\subsection{Lenguajes Utilizados}

Como lenguaje de \textbf{programación}, hemos usado Python\cite{VanRossum2009PythonManual}. Python es considerado por muchos como uno de los lenguajes más útiles para la programación orientada al \textit{machine learning} y \textit{ciencia de datos}. 

Python es un lenguaje de programación \textbf{interpretado y orientado a objetos}, cuya sintaxis hace énfasis en la legibilidad y depuración del código, ofreciendo la potencia y flexibilidad de los lenguajes compilados con una curva de aprendizaje \textit{suave}.\cite{2021Scikit-LearnPython} 

Además, podemos encontrar que varios manuales dedicados a estas materias\cite{VanderPlas2016PythonData} se enfocan directamente en la implementación de estos algoritmos usando este lenguaje, lo que sumado a su sencillez de aprendizaje, su carácter \textit{open source} y la existencia de múltiples librerías y entornos de desarrollo dedicados a cada una de las fases del proceso de \textbf{Ciencia de Datos}, han hecho que nos decantemos por su uso durante el desarrollo de este proyecto.

La versión empleada para las pruebas y la ejecución en el equipo de desarrollo fue \textit{Python 3.9.13}, instalado a partir de la distribución \href{https://www.anaconda.com/}{Anaconda}, que es una distribución \textbf{libre y abierta} de los lenguajes R y Python enfocada principalmente a tareas de \textit{ciencia de datos} y \textit{aprendizaje automático}.

Por otro lado, el interfaz desarrollado ha sido una \textit{aplicación web}, motivo por el cual se han añadido plantillas de estilo \textit{CSS}, scripts en \textit{Javascripts} y lenguaje de marcado \textit{HTML}.

\imagen{libraries}{Librerías más usadas en Data Science}{.8}

Para la redacción de la \textbf{memoria}, empleamos \(\LaTeX\), dada su \textit{portabilidad} y la \textit{facilidad} para ajustarse a los requerimientos de entrega.


\subsection{Entornos de Desarrollo Integrado (IDEs)}

Para la redacción del código fuente e integración continua con el repositorio, se empleó el IDE \href{https://code.visualstudio.com/docs}{Visual Studio Code}, dado que contiene una gran variedad de \href{https://code.visualstudio.com/docs/languages/python}{plugins} que facilitan tanto la redacción como la ejecución de código Python, así como la edición de HTML, Javascript y CSS de cara al interfaz web.

Por otro lado, para la redacción de la memoria en \(\LaTeX\), empleamos el IDE \href{https://www.overleaf.com}{Overleaf}, que se trata de una herramienta de publicación y redacción colaborativa \textbf{en línea}, enfocada a la edición y publicación de documentos científicos, de manera que la revisión de la memoria pudiese realizarse en \textit{tiempo real} por parte del autor y los tutores.
Además, nos permite integrar el desarrollo con \textbf{nuestro repositorio}, así como \textit{enlazar la bibliografía} con un gestor bibliográfico. 

Por último, se ha contado con el apoyo de \href{https://www.mendeley.com/reference-management/reference-manager}{Mendeley Reference Manager} para almacenar las referencias y artículos empleados como apoyo bibliográfico en nuestro trabajo, permitiéndose el acceso a sus recursos gracias a la licencia proporcionada a los estudiantes de la Universidad de Burgos (\textit{modalidad de acceso institucional}).

Tal y como podemos comprobar en la tabla \ref{tabla:IDEs}, hemos variado de un entorno de desarrollo a otro en función de las características del código fuente, en función de las funcionalidades que queramos aprovechar de los mismos de cara al apoyo de nuestra redacción.

\tablaSmallSinColores{Resumen de IDEs}{c|c}{IDEs}
{ \textbf{Lenguaje}  &  \textbf{IDE} \\}{ 
 Python & Visual Studio Code\\ 
 HTML & Visual Studio Code\\
 CSS & Visual Studio Code\\
 JavaScript & Visual Studio Code\\
 MySQL & MySQL Workbench\\
 & phpMyAdmin\\
LaTeX & Overleaf \\
 BibTeX & Mendeley Reference Manager\\}


 \subsection{Librerías}

 Una \textbf{librería} no es más que un conjunto de \textit{archivos de código} empleados para el desarrollo de software. En función de su finalidad, existen librerías para gran variedad de funcionalidades: cálculo matricial, manejo de ficheros, protocolos de comunicaciones, representación gráfica, algoritmia...

 Tal y como hemos reseñado en apartados anteriores, uno de los aspectos más positivos de Python para este proyecto es la disponibilidad de \textit{librerías específicas} para las labores de inteligencia computacional y análisis de datos. 

 De entre todas las usadas, que se resumen en la tabla \ref{tabla:libPython}, conviene \textbf{destacar}: 

 \begin{enumerate}
     \item \textbf{Scikit-Learn}: Esta librería \cite{Pedregosa2011Scikit-learn:Python} es una de las gratuitas para Python. Cuenta con la implementación de varios algoritmos de clasificación, regresión, clustering y reducción de la dimensionalidad, convirtiéndose en una \textit{herramienta básica} para programar sistemas de modelado y análisis de datos.
     \item \textbf{DEAP}: Se trata de un framework para realizar labores de computación evolutiva \cite{Fortin2012DEAP:Easy}, proveyendo a los desarrolladores del \textit{pegamento esencial} para construir algoritmos evolutivos para sistemas sofisticados.
     \item \textbf{Flask}: Framework de python, encargado de realizar labores de \textit{controlador} entre la lógica de negocio y la vista en una aplicación web. Se basa en el motor de renderizado de plantillas \textit{Jinja2} y en la especificación WSGI de Wekzeug.
     \item \textbf{Pandas:} Librería repleta de utilidades para realizar labores de preprocesamiento, análisis y minería de datos. Su uso ha sido esencial a la hora de importar y exportar los conjuntos de datos empleados en las labores de explotación y experimentación de los modelos.
     \item \textbf{Matplotlib:} Contiene funciones dedicadas a la representación de datos. Muy útil para evaluar el rendimiento de los modelos de inteligencia artificial y mostrar de forma empírica sus resultados en la documentación.
 \end{enumerate}

 \tablaSmall{Librerías Python Empleadas}{c|c|c|c|c|c|c}{libPython}
{ \textbf{Librerías}  &  SK-Learn & Pandas & NumPy & Matplotlib & DEAP & Flask \\}{ 
 Preprocesado &  & X &  X & X &  & \\
Análisis de datos & X & X & X & X &  & \\
 Representación de datos & X &  & X & X &  & \\
 Entrenamiento de modelos & X &  & X &  &  & \\
 Evaluación de modelos & X & X & X & X &  & \\
 Optimización & &  & X &  & X & \\
 Evaluación de optimización & X &  & X & X & X & \\
 Métricas y Cálculo &  &  & X &  &  & \\
 Integración API &  &  &  &  &  & X \\}

 \section{Integración y Despliegue}

 \subsection{Docker}

 Un contenedor, o \textit{docker}, nos permite encapsular la lógica de una aplicación, incluyendo su código, librerías y dependencias funcionales, para su ejecución en un entorno virtualizado, sin necesidad de que los usuarios deban preparar su entorno de ejecución o desarrollo para ejecutar las funcionalidades del sistema.

 Este tipo de solución se encuentra ampliamente extendida para el desarrollo y portabilidad de soluciones ML y aplicaciones distribuidas, sobretodo, desde el auge de las tecnologías de \textit{computación en la nube}, ofreciendo una infraestructura idónea para el \textbf{despliegue} y el acceso remoto a estas funcionalidades.

 Para su construcción, debemos instalar el cliente \textbf{Docker Desktop} y confeccionar un fichero \textit{Dockerfile} que especifique a la herramienta las dependencias y la estructura del contenedor:

 \imagen{dockerfile}{Ejemplo de fichero Dockerfile para construcción de un contenedor}{.9}


\subsection{Amazon Web Services}

Tal y como hemos señalado en apartados anteriores,  el objetivo final de este proyecto será obtener una \textit{\textbf{interfaz}} operativa que integre las funcionalidades y requerimientos desarrollados durante el transcurso del trabajo.

Para permitir el acceso \textit{remoto} a las funcionalidades del sistema, hemos optado por desplegar los contenedores y la base de datos haciendo uso del paquete de \textit{Cloud Computing} ofrecido por Amazon Web Services.

En concreto, han sido necesarias las siguientes \textit{dependencias} para el despliegue:

\begin{itemize}
    \item \textbf{Amazon RCS:} Para mantener el esquema de la base de datos relacional y los contenidos persistentes. Usamos el lenguaje MySQL y el motor InnoDB.
    \item \textbf{Amazon ECR:} Almacenamiento de los contenedores desarrollados a partir de Docker, para su posterior despliegue.
    \item \textbf{Amazon ECS:} Creación de un clúster y despliegue de cada uno de los contenedores a modo de \textit{servicios y tareas}.
\end{itemize}


\imagen{RCS}{Panel de control de Amazon RCS}{.9}


